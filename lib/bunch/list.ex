defmodule Bunch.List do
  @moduledoc """
  A bunch of helper functions for list manipulation.
  """

  @doc """
  Generates a list basing on the given `seed`. Allows to return the final seed.

  Successive list elements are generated by calling `f` with the previous `seed`.
  The enumeration finishes when it returns `:halt` or `{:halt, seed}`.

  ## Examples

      iex> #{inspect(__MODULE__)}.unfoldr(10, fn 0 -> :halt; n -> {:cont, n-1} end)
      Enum.to_list(9..0)
      iex> f = fn
      ...>   <<size, content::binary-size(size), rest::binary>> -> {:cont, content, rest}
      ...>   binary -> {:halt, binary}
      ...> end
      iex> #{inspect(__MODULE__)}.unfoldr(<<2, "ab", 3, "cde", 4, "fghi">>, f)
      {~w(ab cde fghi), <<>>}
      iex> #{inspect(__MODULE__)}.unfoldr(<<2, "ab", 3, "cde", 4, "fg">>, f)
      {~w(ab cde), <<4, "fg">>}

  """
  @spec unfoldr(seed, (seed -> {:cont, a, seed} | {:cont, seed} | :halt | {:halt, seed})) ::
          [a] | {[a], seed}
        when seed: any, a: any
  def unfoldr(seed, f) do
    do_unfoldr(seed, f, [])
  end

  defp do_unfoldr(seed, f, acc) do
    case f.(seed) do
      {:cont, value, seed} -> do_unfoldr(seed, f, [value | acc])
      {:cont, seed} -> do_unfoldr(seed, f, [seed | acc])
      {:halt, seed} -> {Enum.reverse(acc), seed}
      :halt -> Enum.reverse(acc)
    end
  end

  @doc """
  The version of `unfoldr/2` that accepts `:ok` and `:error` return tuples.

  Behaves as `unfoldr/2` as long as `:ok` tuples are returned. Upon `:error`
  the processing is stopped and error is returned.

  ## Examples

      iex> f = fn
      iex>   <<a, b, rest::binary>> ->
      iex>     sum = a + b
      iex>     if rem(sum, 2) == 1, do: {:ok, {:cont, sum, rest}}, else: {:error, :even_sum}
      iex>   seed -> {:ok, {:halt, seed}}
      iex> end
      iex> #{inspect(__MODULE__)}.try_unfoldr(<<1,2,3,4,5>>, f)
      {:ok, {[3, 7], <<5>>}}
      iex> #{inspect(__MODULE__)}.try_unfoldr(<<2,4,6,8>>, f)
      {:error, :even_sum}

  """
  @spec try_unfoldr(
          seed,
          (seed ->
             {:ok, {:cont, a, seed} | {:cont, seed} | :halt | {:halt, seed}} | {:error, reason})
        ) ::
          {:ok, [a] | {[a], seed}} | {:error, reason}
        when seed: any, a: any, reason: any
  def try_unfoldr(seed, f) do
    do_try_unfoldr(seed, f, [])
  end

  defp do_try_unfoldr(seed, f, acc) do
    case f.(seed) do
      {:ok, {:cont, value, seed}} -> do_try_unfoldr(seed, f, [value | acc])
      {:ok, {:cont, seed}} -> do_try_unfoldr(seed, f, [seed | acc])
      {:ok, {:halt, seed}} -> {:ok, {Enum.reverse(acc), seed}}
      {:ok, :halt} -> {:ok, Enum.reverse(acc)}
      {:error, reason} -> {:error, reason}
    end
  end
end
